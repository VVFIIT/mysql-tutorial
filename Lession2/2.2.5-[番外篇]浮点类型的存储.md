# [番外篇]浮点类型的存储

### 如何将12.5存储到数据库的？
<br>

##### 根据IEEE 浮点标准，任意一个二进制浮点数V可以表示成下面的形式：
> V = (-1)^S × 2^E × F  
> - 符号(sign) S表示符号位，当S=0，V为正数；当S=1，V为负数。  
> - 分数(fraction) F是一个二进制小数，1≤F<2。
> - 指数(exponent) E的作用是对浮点数加权，这个权重是2的E次幂(可能是负数

##### 按照以上方式，我们先在10进制模式下，换算结果如下：
>12.5 / 2 = 6.25  
>6.25 / 2 = 3.125  
>3.125 / 2 = 1.5625  
>
>12.5是正数，所以S=0  
>一共进行了3次除2操作，所以E=3  
>1.5625大于等于1，小于2，所以F=1.5625  
>
>用IEEE标准表示就是(-1)^0  × 2^3 × 1.5625  

##### 众所周知，计算机系统中存储的是1和0,那么我们使用2进制，换算结果如下：
> 12.5 转化为2进制1100.1  
> 将1100.1的小数点向左偏移3位，得到1.1001
>
>12.5是正数，所以S=0  
>小数点一共向左偏移了3位，所以E=3  
>1.1001大于等于1，小于2，所以F=1.1001  
>
>用IEEE标准表示就是(-1)^0 × 2^3 × 1.1001  

##### 下一步，我们将S E F存入数据库

###### 单精度(32位)
> 如果是一个单精度(32位)浮点数，计算机会在内存中开辟一个32位的存储空间  
>
> 第一位的正负号0代表正，1代表负。  
> 中间八位共可表示2的8次方256个数，指数可以是二补码；或0到255，0到126代表-127到-1，127代表零，128-255代表1-128。  
> 有效数位最左手边的1并不会储存，因为它一定存在（二进制的第一个有效数字必定是1）。换言之，有效数位是24位，实际储存23位。


|1	|2	|3	|4	|5	|6	|7	|8	|9	|10	|11	|12	|13	|14	|15	|16	|17	|18	|19	|20	|21	|22	|23	|24	|25	|26	|27	|28	|29	|30	|31	|32
|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-
|0	|1	|0	|0	|0	|0	|0	|1	|0	|1	|0	|0	|1	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0


###### 双精度(64位)
> 如果是一个双精度(64位)浮点数，计算机会在内存中开辟一个64位的存储空间  
>
> 第一位的正负号0代表正，1代表负。  
> 中间八位共可表示2的11次方2048个数，指数可以是二补码；或0到255，0到1022代表-1023到-1，1023代表零，1024-2047代表1-1023。  
> 有效数位最左手边的1并不会储存，因为它一定存在（二进制的第一个有效数字必定是1）。换言之，有效数位是53位，实际储存52位。

|1	|2	|3	|4	|5	|6	|7	|8	|9	|10	|11	|12	|13	|14	|15	|16	|17	|18	|19	|20	|21	|22	|23	|24	|25	|26	|27	|28	|29	|30	|31	|32	|33	|34	|35	|36	|37	|38	|39	|40	|41	|42	|43	|44	|45	|46	|47	|48	|49	|50	|51	|52	|53	|54	|55	|56	|57	|58	|59	|60	|61	|62	|63	|64
|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-  |-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-	|-
|0	|1	|0	|0	|0	|0	|0	|0	|0	|0	|1	|0	|1	|0	|0	|1	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0  |0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|0	|

<details>
<summary>二进制小数的表示方法</summary>
<pre><code>
<br>
0.625转换为二进制
<br>
0.625 * 2 = 1.25  进位，计1
0.25 * 2 = 0.5    不进位，计0
0.5 * 2 = 1.0     进位，计1
<br>
最终获得二进制位0.101
<br>
2^-1 + 2^-3 = 0.625
<br>
<br>
0.3转化为二进制
0.3 * 2 = 0.6     不进位，计0
0.6 * 2 = 1.2     进位，计1
0.2 * 2 = 0.4     不进位，计0
0.4 * 2 = 0.8     不进位，计0
0.8 * 2 = 1.6     进位，计1
0.6 * 2 = 1.2     进位，计1
0.2 * 2 = 0.4     不进位，计0
0.4 * 2 = 0.8     不进位，计0
0.8 * 2 = 1.6     进位，计1
<br>
最终获得二进制位0.010011001
<br>
2^-2 + 2^-5 + 2^-6 + 2^-9 = 0.298828125

</code></pre>
</details>



为什么会丢失精度？

好在哪里
比较下分别存整数和小数位的存储方式和IEEE的区别


思考：
0.0049怎么如何转换为IEEE

- [浮点数在内存中的存储（IEEE 754）](https://zh.wikipedia.org/wiki/IEEE_754)  

- [浮点数转化二进制工具](http://weitz.de/ieee/)  
