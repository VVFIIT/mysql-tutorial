# HASH索引：
![HASH索引模拟][img_hash_index_url]

### 存储：  
- 1 将索引的列的值通过Hash算法，算出一个哈希码（hash code)  
- 2 将哈希码存入索引篮子中（红线），并将索引篮子的指针指向实际数据（蓝线）

### 查询：  
- 1 将索引的列的值通过Hash算法，算出一个哈希码（hash code)  
- 2 通过哈希码找到对应的索引篮子（？可以通过下标快速定位索引篮子，不需要逐个对比）  
- 3 根据索引篮子的指针，找到实际数据

### 特点
查询速度快，只需对内存进行一次IO访问。

### 哈希冲突
TBD

[img_hash_index_url]:https://github.com/VVFIIT/mysql-tutorial/blob/master/Z/image/Lession2/HashIndex.png




# BTREE索引：
![BTREE索引模拟][img_btree_index_url]  
[线上模拟BTREE的添加和删除](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)

### 存储：  
- 1 根据BTree+的插入规则，通过子节点找到可以添加的叶子的位置，添加叶子，并将叶子的指针指向指向实际数据。

### 查询：  
- 1 通过BTree+的遍历规则，找到对应的叶子。
- 2 根据叶子上的指针，找到实际数据。

### 特点
查询速度快（慢于Hash索引），需对内存进行O(logn)次IO访问。（例如100000000条数据，log以10000为底（每个子节点可以存储100个叶子），查询复杂度为O(logn)为4，需要四次IO访问）
在数据库中，B+Tree的高度一般都在2~4层。mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。

[img_btree_index_url]:https://github.com/VVFIIT/mysql-tutorial/blob/master/Z/image/Lession2/BTreeIndex.png



[HASH索引和BTREE索引的区别](https://dev.mysql.com/doc/refman/8.0/en/index-btree-hash.html)
